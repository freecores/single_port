<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  	      
  <meta http-equiv="CONTENT-TYPE"
 content="text/html; charset=iso-8859-1">
  <title></title>
        	 	      
  <meta name="GENERATOR" content="StarOffice/5.2 (Win32)">
  	      
  <meta name="AUTHOR" content="Robert Paley">
  	      
  <meta name="CREATED" content="20020728;14095738">
  	      
  <meta name="CHANGEDBY" content="Robert Paley">
  	      
  <meta name="CHANGED" content="20020728;15514460">
  	      
  <style>

	<!--

		P.sdfootnote { margin-left: 0.2in; text-indent: -0.2in; margin-bottom: 0in; font-size: 10pt }

		A.sdfootnoteanc { font-size: 57% }

	-->

	</style>
</head>
  <body>
   
<p align="right"><font size="3"></font></p>
 
<h1 style="text-align: center;"><font size="4" style="font-size: 16pt;">Description
 of single_port memory and test environment.</font></h1>
   
<h2>Abstract: </h2>
   
<p><span style="">A VHDL simulation model for an asynchronous single port 
memory is described. The memory is implemented as three different architectures, 
a simple one and 2 ones which are optimized for efficient use of simulator 
memory. Data and address buses are unconstrained, so multiple instances with 
different address and data bus widths can be implemented in one single design. 
</span>A testbench is also provided.<br>
 </p>
   
<h2>Port Interface:</h2>
   
<table width="757" border="1" cellpadding="5" cellspacing="4">
  	<col width="108"> 	<col width="118"> 	<col width="483"> 	<thead> 		<tr
 valign="top">
  			<th width="108"> 				          
    <p>Port Name</p>
  			</th>
  			<th width="118"> 				          
    <p>Type</p>
  			</th>
  			<th width="483"> 				          
    <p>Description</p>
  			</th>
  		</tr>
  	</thead> 	<tbody>
  		<tr valign="top">
  			<td width="108"> 				              
      <p>rnwtQ</p>
  			</td>
  			<td width="118"> 				              
      <p>Time</p>
  			</td>
  			<td width="483"> 				              
      <p>Time delay from rnw = read until data appears on q data bus.</p>
  			</td>
  		</tr>
  		<tr valign="top">
  			<td width="108"> 				              
      <p>d</p>
  			</td>
  			<td width="118"> 				       STD_LOGIC_VECTOR<br>
       </td>
  			<td width="483"> 				              
      <p>Input data bus,&nbsp;unconstrained</p>
  			</td>
  		</tr>
  		<tr valign="top">
  			<td width="108"> 				              
      <p>q</p>
  			</td>
  			<td width="118"> 				              
      <p>STD_LOGIC_VECTOR<br>
       </p>
  			</td>
  			<td width="483"> 				              
      <p>Output data bus,&nbsp;unconstrained</p>
  			</td>
  		</tr>
  		<tr valign="top">
  			<td width="108"> 				              
      <p>a</p>
  			</td>
  			<td width="118"> 				              
      <p>STD_LOGIC_VECTOR<br>
       </p>
  			</td>
  			<td width="483"> 				              
      <p>Address bus, unconstrained</p>
  			</td>
  		</tr>
  		<tr valign="top">
  			<td width="108"> 				              
      <p>rnw</p>
  			</td>
  			<td width="118"> 				              
      <p>STD_LOGIC</p>
  			</td>
  			<td width="483"> 				              
      <p>Read not write port</p>
  			</td>
  		</tr>
  		<tr valign="top">
  			<td width="108"> 				              
      <p>dealloc_mem</p>
  			</td>
  			<td width="118"> 				              
      <p>BOOLEAN</p>
  			</td>
  			<td width="483"> 				              
      <p>When set to true, deallocate linked list memory.</p>
  			</td>
  		</tr>
  	      
  </tbody>  
</table>
   
<h2>Functional Description:</h2>
   
<p><span style="">The first architecture is called ArrayMemNoFlag, and implements 
the memory core as an array of STD_LOGIC_VECTOR. This is the simplest architecture. 
It is provided for comparison with the models below but not recommended for 
use in your design.<o:p></o:p></span></p>
    
<p><span style="">The second architecture is called ArrayMem, and implements 
the memory core as an array of BIT_VECTOR. This arrangement allows less workstation 
memory to be used than the ArrayMemNoFlag architecture. Use this architecture
 if most addresses in the simulated memory are written at least once.<o:p></o:p></span></p>
   <span style="">The third architecture is called LinkedList, and implements 
the memory core as a linked list of arrays of BIT_VECTOR. Each array in the 
linked list is a page of memory whose size is specified in single_port_pkg. 
This arrangement allows less workstation memory to be used than either the 
ArrayMemNoFlag or ArrayMem architectures because memory representing the array
data is only allocated if the memory is actually written to. To de-allocate 
the memory in the linked list, set dealloc_mem to true. Use this architecture 
if a significant portion of your simulated memory (which need not be contiguous) 
is never written to.<br>
 <br>
 All 3 architectures are asynchronous and triggered with any change of </span><span
 style="">d, a or rnw</span> (and dealloc_mem for the LinkedList architecture). 
<span style="">When rnw = '0', the data on bus "d" is loaded into the memory 
at the location specified by the addres bus "a". When rnw = '1', the data 
located in memory address "a" is loaded onto the output data bus "q". If a
memory location is read which was not written to during the current simulation, 
'U's are loaded onto the memory bus.</span><br>
 
<h2>Functional Timing:</h2>
   
<p><span style="">The single port memory is asynchronous and is triggered 
on any change of d, a or rnw. When rnw is cleared to '0', the write occurs 
at the same time as rnw'transaction. When a read occurs, with rnw = '1' , 
data appears on the Q bus rnwtQ ns after rnw is set to '1'. The below sample 
timing diagram illustrates both a read and write operation.</span><br>
 </p>
 
<p><img src="../images/timing.jpg" name="Graphic1" align="left"
 width="958" height="251" border="0">
 <br clear="left">
  </p>
   
<h2>Testbench Description:</h2>
   
<p>The test bench is arranged as a client server architecture as specified 
by Bergeron<a class="sdfootnoteanc" name="sdfootnote1anc"
 href="#sdfootnote1sym"><sup>1</sup></a>. A diagram illustrating the testbench 
is given below.<br>
  <br>
  <img src="../images/tbschematic.jpg" name="Graphic2" align="left"
 width="838" height="371" border="0">
 <br clear="left">
  Two tests are specified in tc_single_port component. The first test writes 
data to two logical memory pages, and then reads them back verifying the correct
data. The test case writes an error message to the console for every miscompare.
The second case verifies that the single_port memory model outputs unknowns
to the q bus if a read occurs for an unwritten memory location. Six configurations
are specified in the test bench architecture tb_single_port, running both
tests for each single_port architecture. <br>
  </p>
   
<h2>Usage:</h2>
   
<p>A Makefile is used to compile and run all of the tests in a Unix or like 
environment, such as Cygwin. The compilation and simulation is targetted to
the SymphonyEDA tool available at <a href="http://www.symphonyeda.com">www.symphonyeda.com</a>.</p>
   
<p>The source files and Makefile are located in {top}/VHDL<br>
  <br>
  To compile: make com</p>
   
<p>To simulate all of the tests: make sim<br>
  </p>
   
<p>To clean the compiled library: make clean</p>
   
<p>The tests are labeled :</p>
   
<ul>
    <li>ll_error</li>
    <li>ll_main</li>
    <li>mem_main<br>
    </li>
    <li>mem_error<br>
    </li>
    <li>memnoflag_main<br>
    </li>
    <li>memnoflag_error<br>
    </li>
   
</ul>
   
<p>To simulate any of these tests, type make {testname}</p>
   
<p>Please contact Robert Paley at <a href="mailto:rpaley_yid@yahoo.com">rpaley_yid@opencores.org</a>
 or Michael Geng at <a href="mailto:vhdl@michaelgeng.de">vhdl@michaelgeng.de</a> 
if you have any questions or comments. </p>
   
<div id="sdfootnote1"> 	  
<p class="sdfootnote" style="margin-bottom: 0.2in;"><a
 class="sdfootnotesym" name="sdfootnote1sym" href="#sdfootnote1anc">1</a>Writing
 	Testbenches , Functional Verification of HDL Testbenches. Chapter 6 	&#8211;
ISBN 0-7923-7766-4</p>
  </div>
  <br>
 <br>
</body>
</html>
